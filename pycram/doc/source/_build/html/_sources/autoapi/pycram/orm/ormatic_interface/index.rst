pycram.orm.ormatic_interface
============================

.. py:module:: pycram.orm.ormatic_interface


Attributes
----------

.. autoapisummary::

   pycram.orm.ormatic_interface.executiondatadao_added_world_modifications_association
   pycram.orm.ormatic_interface.movetcpwaypointsmotiondao_waypoints_association
   pycram.orm.ormatic_interface.planmappingdao_nodes_association
   pycram.orm.ormatic_interface.planmappingdao_edges_association
   pycram.orm.ormatic_interface.shapecollectiondao_shapes_association
   pycram.orm.ormatic_interface.worldmappingdao_kinematic_structure_entities_association
   pycram.orm.ormatic_interface.worldmappingdao_connections_association
   pycram.orm.ormatic_interface.worldmappingdao_semantic_annotations_association
   pycram.orm.ormatic_interface.worldmappingdao_degrees_of_freedom_association
   pycram.orm.ormatic_interface.hasdoorsdao_doors_association
   pycram.orm.ormatic_interface.cupboarddao_doors_association
   pycram.orm.ormatic_interface.hasdrawersdao_drawers_association
   pycram.orm.ormatic_interface.cabinetdao_doors_association
   pycram.orm.ormatic_interface.cabinetdao_drawers_association
   pycram.orm.ormatic_interface.dresserdao_doors_association
   pycram.orm.ormatic_interface.dresserdao_drawers_association
   pycram.orm.ormatic_interface.wardrobedao_doors_association
   pycram.orm.ormatic_interface.wardrobedao_drawers_association
   pycram.orm.ormatic_interface.abstractrobotdao_manipulators_association
   pycram.orm.ormatic_interface.abstractrobotdao_sensors_association
   pycram.orm.ormatic_interface.abstractrobotdao_manipulator_chains_association
   pycram.orm.ormatic_interface.abstractrobotdao_sensor_chains_association
   pycram.orm.ormatic_interface.kinematicchaindao_sensors_association
   pycram.orm.ormatic_interface.worldmodelmodificationblockdao_modifications_association


Classes
-------

.. autoapisummary::

   pycram.orm.ormatic_interface.Base
   pycram.orm.ormatic_interface.AccelerationVariableDAO
   pycram.orm.ormatic_interface.BoundingBoxDAO
   pycram.orm.ormatic_interface.CallbackDAO
   pycram.orm.ormatic_interface.CollisionCheckingConfigDAO
   pycram.orm.ormatic_interface.CollisionPairManagerDAO
   pycram.orm.ormatic_interface.ColorDAO
   pycram.orm.ormatic_interface.DesignatorDescriptionDAO
   pycram.orm.ormatic_interface.ActionDescriptionDAO
   pycram.orm.ormatic_interface.CarryActionDAO
   pycram.orm.ormatic_interface.CloseActionDAO
   pycram.orm.ormatic_interface.CuttingActionDAO
   pycram.orm.ormatic_interface.BaseMotionDAO
   pycram.orm.ormatic_interface.ClosingMotionDAO
   pycram.orm.ormatic_interface.DetectActionDAO
   pycram.orm.ormatic_interface.DetectingMotionDAO
   pycram.orm.ormatic_interface.EfficientTransportActionDAO
   pycram.orm.ormatic_interface.ExecutionDataDAO
   pycram.orm.ormatic_interface.FaceAtActionDAO
   pycram.orm.ormatic_interface.FieldOfViewDAO
   pycram.orm.ormatic_interface.GraspDescriptionDAO
   pycram.orm.ormatic_interface.GraspingActionDAO
   pycram.orm.ormatic_interface.HeaderDAO
   pycram.orm.ormatic_interface.HomogeneousTransformationMatrixMappingDAO
   pycram.orm.ormatic_interface.IsPerceivableDAO
   pycram.orm.ormatic_interface.JerkVariableDAO
   pycram.orm.ormatic_interface.LookAtActionDAO
   pycram.orm.ormatic_interface.LookingMotionDAO
   pycram.orm.ormatic_interface.MixingActionDAO
   pycram.orm.ormatic_interface.ModelChangeCallbackDAO
   pycram.orm.ormatic_interface.MoveAndPickUpActionDAO
   pycram.orm.ormatic_interface.MoveAndPlaceActionDAO
   pycram.orm.ormatic_interface.MoveGripperMotionDAO
   pycram.orm.ormatic_interface.MoveJointsMotionDAO
   pycram.orm.ormatic_interface.MoveMotionDAO
   pycram.orm.ormatic_interface.MoveTCPMotionDAO
   pycram.orm.ormatic_interface.MoveTCPWaypointsMotionDAO
   pycram.orm.ormatic_interface.MoveTorsoActionDAO
   pycram.orm.ormatic_interface.NavigateActionDAO
   pycram.orm.ormatic_interface.OpenActionDAO
   pycram.orm.ormatic_interface.OpeningMotionDAO
   pycram.orm.ormatic_interface.ParkArmsActionDAO
   pycram.orm.ormatic_interface.PickAndPlaceActionDAO
   pycram.orm.ormatic_interface.PickUpActionDAO
   pycram.orm.ormatic_interface.PlaceActionDAO
   pycram.orm.ormatic_interface.PlanMappingDAO
   pycram.orm.ormatic_interface.LanguagePlanDAO
   pycram.orm.ormatic_interface.CodePlanDAO
   pycram.orm.ormatic_interface.MonitorPlanDAO
   pycram.orm.ormatic_interface.ParallelPlanDAO
   pycram.orm.ormatic_interface.PlanEdgeDAO
   pycram.orm.ormatic_interface.PlanNodeMappingDAO
   pycram.orm.ormatic_interface.DesignatorNodeMappingDAO
   pycram.orm.ormatic_interface.ActionNodeMappingDAO
   pycram.orm.ormatic_interface.MotionNodeMappingDAO
   pycram.orm.ormatic_interface.LanguageNodeDAO
   pycram.orm.ormatic_interface.CodeNodeDAO
   pycram.orm.ormatic_interface.ParallelNodeDAO
   pycram.orm.ormatic_interface.Point3MappingDAO
   pycram.orm.ormatic_interface.PoseMappingDAO
   pycram.orm.ormatic_interface.PoseStampedDAO
   pycram.orm.ormatic_interface.GraspPoseDAO
   pycram.orm.ormatic_interface.PositionVariableDAO
   pycram.orm.ormatic_interface.PouringActionDAO
   pycram.orm.ormatic_interface.PreferredGraspAlignmentDAO
   pycram.orm.ormatic_interface.PrefixedNameDAO
   pycram.orm.ormatic_interface.PyCramPoseDAO
   pycram.orm.ormatic_interface.PyCRAMQuaternionMappingDAO
   pycram.orm.ormatic_interface.PyCramVector3DAO
   pycram.orm.ormatic_interface.QuaternionMappingDAO
   pycram.orm.ormatic_interface.ReachActionDAO
   pycram.orm.ormatic_interface.ReachMotionDAO
   pycram.orm.ormatic_interface.RepeatPlanDAO
   pycram.orm.ormatic_interface.ResolvedActionNodeMappingDAO
   pycram.orm.ormatic_interface.RotationMatrixMappingDAO
   pycram.orm.ormatic_interface.ScaleDAO
   pycram.orm.ormatic_interface.SearchActionDAO
   pycram.orm.ormatic_interface.SequentialNodeDAO
   pycram.orm.ormatic_interface.MonitorNodeDAO
   pycram.orm.ormatic_interface.RepeatNodeDAO
   pycram.orm.ormatic_interface.SequentialPlanDAO
   pycram.orm.ormatic_interface.SetGripperActionDAO
   pycram.orm.ormatic_interface.ShapeDAO
   pycram.orm.ormatic_interface.BoxDAO
   pycram.orm.ormatic_interface.CylinderDAO
   pycram.orm.ormatic_interface.MeshDAO
   pycram.orm.ormatic_interface.FileMeshDAO
   pycram.orm.ormatic_interface.ShapeCollectionDAO
   pycram.orm.ormatic_interface.BoundingBoxCollectionDAO
   pycram.orm.ormatic_interface.SpatialRelationDAO
   pycram.orm.ormatic_interface.InsideOfDAO
   pycram.orm.ormatic_interface.SphereDAO
   pycram.orm.ormatic_interface.StateChangeCallbackDAO
   pycram.orm.ormatic_interface.TransformDAO
   pycram.orm.ormatic_interface.TransformStampedDAO
   pycram.orm.ormatic_interface.TransportActionDAO
   pycram.orm.ormatic_interface.TriangleMeshDAO
   pycram.orm.ormatic_interface.TryAllNodeDAO
   pycram.orm.ormatic_interface.TryAllPLanDAO
   pycram.orm.ormatic_interface.TryInOrderNodeDAO
   pycram.orm.ormatic_interface.TryInOrderPlanDAO
   pycram.orm.ormatic_interface.Vector3MappingDAO
   pycram.orm.ormatic_interface.Vector3StampedDAO
   pycram.orm.ormatic_interface.VelocityVariableDAO
   pycram.orm.ormatic_interface.ViewDependentSpatialRelationDAO
   pycram.orm.ormatic_interface.AboveDAO
   pycram.orm.ormatic_interface.BehindDAO
   pycram.orm.ormatic_interface.BelowDAO
   pycram.orm.ormatic_interface.InFrontOfDAO
   pycram.orm.ormatic_interface.LeftOfDAO
   pycram.orm.ormatic_interface.RightOfDAO
   pycram.orm.ormatic_interface.WorldMappingDAO
   pycram.orm.ormatic_interface.WorldEntityDAO
   pycram.orm.ormatic_interface.ConnectionDAO
   pycram.orm.ormatic_interface.ActiveConnectionDAO
   pycram.orm.ormatic_interface.ActiveConnection1DOFDAO
   pycram.orm.ormatic_interface.PrismaticConnectionDAO
   pycram.orm.ormatic_interface.RevoluteConnectionDAO
   pycram.orm.ormatic_interface.OmniDriveDAO
   pycram.orm.ormatic_interface.Connection6DoFDAO
   pycram.orm.ormatic_interface.FixedConnectionDAO
   pycram.orm.ormatic_interface.SemanticAnnotationDAO
   pycram.orm.ormatic_interface.DoubleDoorDAO
   pycram.orm.ormatic_interface.DrawerDAO
   pycram.orm.ormatic_interface.FridgeDAO
   pycram.orm.ormatic_interface.FurnitureDAO
   pycram.orm.ormatic_interface.HasBodyDAO
   pycram.orm.ormatic_interface.BaseballDAO
   pycram.orm.ormatic_interface.BedDAO
   pycram.orm.ormatic_interface.BookDAO
   pycram.orm.ormatic_interface.BookFrontDAO
   pycram.orm.ormatic_interface.ChairDAO
   pycram.orm.ormatic_interface.ArmchairDAO
   pycram.orm.ormatic_interface.OfficeChairDAO
   pycram.orm.ormatic_interface.ClothDAO
   pycram.orm.ormatic_interface.ContainerDAO
   pycram.orm.ormatic_interface.BottleDAO
   pycram.orm.ormatic_interface.MustardBottleDAO
   pycram.orm.ormatic_interface.SoapBottleDAO
   pycram.orm.ormatic_interface.WineBottleDAO
   pycram.orm.ormatic_interface.GarbageBinDAO
   pycram.orm.ormatic_interface.ProcthorBoxDAO
   pycram.orm.ormatic_interface.SaltContainerDAO
   pycram.orm.ormatic_interface.CookingContainerDAO
   pycram.orm.ormatic_interface.KettleDAO
   pycram.orm.ormatic_interface.PanDAO
   pycram.orm.ormatic_interface.PotDAO
   pycram.orm.ormatic_interface.CuttleryDAO
   pycram.orm.ormatic_interface.ForkDAO
   pycram.orm.ormatic_interface.KnifeDAO
   pycram.orm.ormatic_interface.SpoonDAO
   pycram.orm.ormatic_interface.DecorDAO
   pycram.orm.ormatic_interface.WallDecorDAO
   pycram.orm.ormatic_interface.PosterDAO
   pycram.orm.ormatic_interface.DoorDAO
   pycram.orm.ormatic_interface.DrinkingContainerDAO
   pycram.orm.ormatic_interface.CupDAO
   pycram.orm.ormatic_interface.MugDAO
   pycram.orm.ormatic_interface.DroneDAO
   pycram.orm.ormatic_interface.FoodDAO
   pycram.orm.ormatic_interface.BreadDAO
   pycram.orm.ormatic_interface.CandyDAO
   pycram.orm.ormatic_interface.CerealDAO
   pycram.orm.ormatic_interface.CheezeItDAO
   pycram.orm.ormatic_interface.GelatinBoxDAO
   pycram.orm.ormatic_interface.MilkDAO
   pycram.orm.ormatic_interface.NoodlesDAO
   pycram.orm.ormatic_interface.PringlesDAO
   pycram.orm.ormatic_interface.ProduceDAO
   pycram.orm.ormatic_interface.AppleDAO
   pycram.orm.ormatic_interface.BananaDAO
   pycram.orm.ormatic_interface.LettuceDAO
   pycram.orm.ormatic_interface.OrangeDAO
   pycram.orm.ormatic_interface.PotatoDAO
   pycram.orm.ormatic_interface.TomatoDAO
   pycram.orm.ormatic_interface.TomatoSoupDAO
   pycram.orm.ormatic_interface.TunaCanDAO
   pycram.orm.ormatic_interface.HandleDAO
   pycram.orm.ormatic_interface.HouseplantDAO
   pycram.orm.ormatic_interface.LidDAO
   pycram.orm.ormatic_interface.PanLidDAO
   pycram.orm.ormatic_interface.PotLidDAO
   pycram.orm.ormatic_interface.LiquidCapDAO
   pycram.orm.ormatic_interface.PenDAO
   pycram.orm.ormatic_interface.PencilDAO
   pycram.orm.ormatic_interface.SaltPepperShakerDAO
   pycram.orm.ormatic_interface.ShelvingUnitDAO
   pycram.orm.ormatic_interface.SinkDAO
   pycram.orm.ormatic_interface.SofaDAO
   pycram.orm.ormatic_interface.SprayBottleDAO
   pycram.orm.ormatic_interface.StatueDAO
   pycram.orm.ormatic_interface.TableDAO
   pycram.orm.ormatic_interface.CoffeeTableDAO
   pycram.orm.ormatic_interface.DeskDAO
   pycram.orm.ormatic_interface.DiningTableDAO
   pycram.orm.ormatic_interface.SideTableDAO
   pycram.orm.ormatic_interface.VaseDAO
   pycram.orm.ormatic_interface.WallPanelDAO
   pycram.orm.ormatic_interface.HasDoorsDAO
   pycram.orm.ormatic_interface.CupboardDAO
   pycram.orm.ormatic_interface.HasDrawersDAO
   pycram.orm.ormatic_interface.CabinetDAO
   pycram.orm.ormatic_interface.DresserDAO
   pycram.orm.ormatic_interface.WardrobeDAO
   pycram.orm.ormatic_interface.HasRegionDAO
   pycram.orm.ormatic_interface.ApertureDAO
   pycram.orm.ormatic_interface.HasSupportingSurfaceDAO
   pycram.orm.ormatic_interface.BowlDAO
   pycram.orm.ormatic_interface.FloorDAO
   pycram.orm.ormatic_interface.PlateDAO
   pycram.orm.ormatic_interface.RoomDAO
   pycram.orm.ormatic_interface.RootedSemanticAnnotationDAO
   pycram.orm.ormatic_interface.AgentDAO
   pycram.orm.ormatic_interface.AbstractRobotDAO
   pycram.orm.ormatic_interface.HumanDAO
   pycram.orm.ormatic_interface.SemanticEnvironmentAnnotationDAO
   pycram.orm.ormatic_interface.SemanticRobotAnnotationDAO
   pycram.orm.ormatic_interface.KinematicChainDAO
   pycram.orm.ormatic_interface.ArmDAO
   pycram.orm.ormatic_interface.FingerDAO
   pycram.orm.ormatic_interface.NeckDAO
   pycram.orm.ormatic_interface.TorsoDAO
   pycram.orm.ormatic_interface.ManipulatorDAO
   pycram.orm.ormatic_interface.ParallelGripperDAO
   pycram.orm.ormatic_interface.SensorDAO
   pycram.orm.ormatic_interface.CameraDAO
   pycram.orm.ormatic_interface.WallDAO
   pycram.orm.ormatic_interface.WorldEntityWithIDDAO
   pycram.orm.ormatic_interface.ActuatorDAO
   pycram.orm.ormatic_interface.DegreeOfFreedomMappingDAO
   pycram.orm.ormatic_interface.KinematicStructureEntityDAO
   pycram.orm.ormatic_interface.BodyDAO
   pycram.orm.ormatic_interface.RegionDAO
   pycram.orm.ormatic_interface.WorldModelModificationDAO
   pycram.orm.ormatic_interface.AddActuatorModificationDAO
   pycram.orm.ormatic_interface.AddConnectionModificationDAO
   pycram.orm.ormatic_interface.AddDegreeOfFreedomModificationDAO
   pycram.orm.ormatic_interface.AddKinematicStructureEntityModificationDAO
   pycram.orm.ormatic_interface.AddSemanticAnnotationModificationDAO
   pycram.orm.ormatic_interface.RemoveActuatorModificationDAO
   pycram.orm.ormatic_interface.RemoveBodyModificationDAO
   pycram.orm.ormatic_interface.RemoveConnectionModificationDAO
   pycram.orm.ormatic_interface.RemoveDegreeOfFreedomModificationDAO
   pycram.orm.ormatic_interface.RemoveSemanticAnnotationModificationDAO
   pycram.orm.ormatic_interface.SetDofHasHardwareInterfaceDAO
   pycram.orm.ormatic_interface.WorldModelModificationBlockDAO
   pycram.orm.ormatic_interface.WorldStateMappingDAO


Module Contents
---------------

.. py:class:: Base

   Bases: :py:obj:`sqlalchemy.orm.DeclarativeBase`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: type_mappings


.. py:data:: executiondatadao_added_world_modifications_association

.. py:data:: movetcpwaypointsmotiondao_waypoints_association

.. py:data:: planmappingdao_nodes_association

.. py:data:: planmappingdao_edges_association

.. py:data:: shapecollectiondao_shapes_association

.. py:data:: worldmappingdao_kinematic_structure_entities_association

.. py:data:: worldmappingdao_connections_association

.. py:data:: worldmappingdao_semantic_annotations_association

.. py:data:: worldmappingdao_degrees_of_freedom_association

.. py:data:: hasdoorsdao_doors_association

.. py:data:: cupboarddao_doors_association

.. py:data:: hasdrawersdao_drawers_association

.. py:data:: cabinetdao_doors_association

.. py:data:: cabinetdao_drawers_association

.. py:data:: dresserdao_doors_association

.. py:data:: dresserdao_drawers_association

.. py:data:: wardrobedao_doors_association

.. py:data:: wardrobedao_drawers_association

.. py:data:: abstractrobotdao_manipulators_association

.. py:data:: abstractrobotdao_sensors_association

.. py:data:: abstractrobotdao_manipulator_chains_association

.. py:data:: abstractrobotdao_sensor_chains_association

.. py:data:: kinematicchaindao_sensors_association

.. py:data:: worldmodelmodificationblockdao_modifications_association

.. py:class:: AccelerationVariableDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.degree_of_freedom.AccelerationVariable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AccelerationVariableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof
      :type:  sqlalchemy.orm.Mapped[DegreeOfFreedomMappingDAO]


.. py:class:: BoundingBoxDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.BoundingBox`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BoundingBoxDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: min_x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: min_y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: min_z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: max_x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: max_y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: max_z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: origin_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: origin
      :type:  sqlalchemy.orm.Mapped[HomogeneousTransformationMatrixMappingDAO]


.. py:class:: CallbackDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.callbacks.callback.Callback`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CallbackDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: world_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: world
      :type:  sqlalchemy.orm.Mapped[WorldMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: CollisionCheckingConfigDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.CollisionCheckingConfig`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CollisionCheckingConfigDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: buffer_zone_distance
      :type:  sqlalchemy.orm.Mapped[Optional[float]]


   .. py:attribute:: violated_distance
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: disabled
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: max_avoided_bodies
      :type:  sqlalchemy.orm.Mapped[int]


.. py:class:: CollisionPairManagerDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world.CollisionPairManager`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CollisionPairManagerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: world_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: world
      :type:  sqlalchemy.orm.Mapped[WorldMappingDAO]


.. py:class:: ColorDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Color`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ColorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: R
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: G
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: B
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: A
      :type:  sqlalchemy.orm.Mapped[float]


.. py:class:: DesignatorDescriptionDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.designator.DesignatorDescription`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DesignatorDescriptionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: plan_node_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: plan_node
      :type:  sqlalchemy.orm.Mapped[PlanNodeMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ActionDescriptionDAO

   Bases: :py:obj:`DesignatorDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.base.ActionDescription`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ActionDescriptionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CarryActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.robot_body.CarryAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CarryActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: align
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: tip_link
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: root_link
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: CloseActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.container.CloseAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CloseActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: grasping_prepose_distance
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: CuttingActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.tool_based.CuttingAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CuttingActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: technique
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: slice_thickness
      :type:  sqlalchemy.orm.Mapped[Optional[float]]


   .. py:attribute:: object__id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tool_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: tool
      :type:  sqlalchemy.orm.Mapped[SemanticAnnotationDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BaseMotionDAO

   Bases: :py:obj:`DesignatorDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.base.BaseMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BaseMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ClosingMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.container.ClosingMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ClosingMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: object_part_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_part
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: DetectActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.misc.DetectAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DetectActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: technique
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.DetectionTechnique]


   .. py:attribute:: object_sem_annotation
      :type:  sqlalchemy.orm.Mapped[krrood.ormatic.custom_types.TypeType]


   .. py:attribute:: region_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: region
      :type:  sqlalchemy.orm.Mapped[RegionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: DetectingMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.misc.DetectingMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DetectingMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: EfficientTransportActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.transporting.EfficientTransportAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'EfficientTransportActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ExecutionDataDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.dataclasses.ExecutionData`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ExecutionDataDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: manipulated_body_name
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: execution_start_world_state
      :type:  sqlalchemy.orm.Mapped[pycram.orm.model.NumpyType]


   .. py:attribute:: execution_end_world_state
      :type:  sqlalchemy.orm.Mapped[Optional[pycram.orm.model.NumpyType]]


   .. py:attribute:: execution_start_pose_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: execution_end_pose_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: manipulated_body_pose_start_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: manipulated_body_pose_end_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: manipulated_body_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: execution_start_pose
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: execution_end_pose
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: added_world_modifications
      :type:  sqlalchemy.orm.Mapped[List[WorldModelModificationBlockDAO]]


   .. py:attribute:: manipulated_body_pose_start
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: manipulated_body_pose_end
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: manipulated_body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


.. py:class:: FaceAtActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.facing.FaceAtAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FaceAtActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: keep_joint_states
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: pose_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: pose
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: FieldOfViewDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.FieldOfView`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FieldOfViewDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: vertical_angle
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: horizontal_angle
      :type:  sqlalchemy.orm.Mapped[float]


.. py:class:: GraspDescriptionDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.grasp.GraspDescription`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'GraspDescriptionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: approach_direction
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.ApproachDirection]


   .. py:attribute:: vertical_alignment
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.VerticalAlignment]


   .. py:attribute:: rotate_gripper
      :type:  sqlalchemy.orm.Mapped[bool]


.. py:class:: GraspingActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.pick_up.GraspingAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'GraspingActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: prepose_distance
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: HeaderDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.Header`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HeaderDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: stamp
      :type:  sqlalchemy.orm.Mapped[datetime.datetime]


   .. py:attribute:: sequence
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: frame_id_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: frame_id
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


.. py:class:: HomogeneousTransformationMatrixMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.HomogeneousTransformationMatrixMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HomogeneousTransformationMatrixMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: position_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: rotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: child_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: position
      :type:  sqlalchemy.orm.Mapped[Point3MappingDAO]


   .. py:attribute:: rotation
      :type:  sqlalchemy.orm.Mapped[QuaternionMappingDAO]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: child_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: IsPerceivableDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.IsPerceivable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'IsPerceivableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: __mapper_args__


.. py:class:: JerkVariableDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.degree_of_freedom.JerkVariable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'JerkVariableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof
      :type:  sqlalchemy.orm.Mapped[DegreeOfFreedomMappingDAO]


.. py:class:: LookAtActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.navigation.LookAtAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LookAtActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: LookingMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.robot_body.LookingMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LookingMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MixingActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.tool_based.MixingAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MixingActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: technique
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: object__id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tool_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: tool
      :type:  sqlalchemy.orm.Mapped[SemanticAnnotationDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ModelChangeCallbackDAO

   Bases: :py:obj:`CallbackDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.callbacks.callback.ModelChangeCallback`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ModelChangeCallbackDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveAndPickUpActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.transporting.MoveAndPickUpAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveAndPickUpActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: keep_joint_states
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: standing_position_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: standing_position
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveAndPlaceActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.transporting.MoveAndPlaceAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveAndPlaceActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: keep_joint_states
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: standing_position_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: standing_position
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveGripperMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.gripper.MoveGripperMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveGripperMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: motion
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.GripperState]


   .. py:attribute:: gripper
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: allow_gripper_collision
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveJointsMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.robot_body.MoveJointsMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveJointsMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: align
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: tip_link
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: root_link
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: tip_normal_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: root_normal_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: tip_normal
      :type:  sqlalchemy.orm.Mapped[Vector3StampedDAO]


   .. py:attribute:: root_normal
      :type:  sqlalchemy.orm.Mapped[Vector3StampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.navigation.MoveMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: keep_joint_states
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: target_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveTCPMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.gripper.MoveTCPMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveTCPMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: allow_gripper_collision
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: target_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveTCPWaypointsMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.gripper.MoveTCPWaypointsMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveTCPWaypointsMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: allow_gripper_collision
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: movement_type
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.WaypointsMovementType]


   .. py:attribute:: waypoints
      :type:  sqlalchemy.orm.Mapped[List[PoseStampedDAO]]


   .. py:attribute:: __mapper_args__


.. py:class:: MoveTorsoActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.robot_body.MoveTorsoAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MoveTorsoActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: torso_state
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.TorsoState]


   .. py:attribute:: __mapper_args__


.. py:class:: NavigateActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.navigation.NavigateAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'NavigateActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: keep_joint_states
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: OpenActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.container.OpenAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'OpenActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: grasping_prepose_distance
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: OpeningMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.container.OpeningMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'OpeningMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: object_part_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_part
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ParkArmsActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.robot_body.ParkArmsAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ParkArmsActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: __mapper_args__


.. py:class:: PickAndPlaceActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.transporting.PickAndPlaceAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PickAndPlaceActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PickUpActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.pick_up.PickUpAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PickUpActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PlaceActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.placing.PlaceAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PlaceActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PlanMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.PlanMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PlanMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: nodes
      :type:  sqlalchemy.orm.Mapped[List[PlanNodeMappingDAO]]


   .. py:attribute:: edges
      :type:  sqlalchemy.orm.Mapped[List[PlanEdgeDAO]]


   .. py:attribute:: __mapper_args__


.. py:class:: LanguagePlanDAO

   Bases: :py:obj:`PlanMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.LanguagePlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LanguagePlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CodePlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.CodePlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CodePlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MonitorPlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.MonitorPlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MonitorPlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ParallelPlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.ParallelPlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ParallelPlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PlanEdgeDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.PlanEdge`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PlanEdgeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: child_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent
      :type:  sqlalchemy.orm.Mapped[PlanNodeMappingDAO]


   .. py:attribute:: child
      :type:  sqlalchemy.orm.Mapped[PlanNodeMappingDAO]


.. py:class:: PlanNodeMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.PlanNodeMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PlanNodeMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: status
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.TaskStatus]


   .. py:attribute:: start_time
      :type:  sqlalchemy.orm.Mapped[Optional[datetime.datetime]]


   .. py:attribute:: end_time
      :type:  sqlalchemy.orm.Mapped[Optional[datetime.datetime]]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: __mapper_args__


.. py:class:: DesignatorNodeMappingDAO

   Bases: :py:obj:`PlanNodeMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.DesignatorNodeMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DesignatorNodeMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: designator_type
      :type:  sqlalchemy.orm.Mapped[krrood.ormatic.custom_types.TypeType]


   .. py:attribute:: designator_ref_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: designator_ref
      :type:  sqlalchemy.orm.Mapped[DesignatorDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ActionNodeMappingDAO

   Bases: :py:obj:`DesignatorNodeMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.ActionNodeMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ActionNodeMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MotionNodeMappingDAO

   Bases: :py:obj:`DesignatorNodeMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.MotionNodeMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MotionNodeMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: LanguageNodeDAO

   Bases: :py:obj:`PlanNodeMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.LanguageNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LanguageNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: designator_type
      :type:  sqlalchemy.orm.Mapped[krrood.ormatic.custom_types.TypeType]


   .. py:attribute:: __mapper_args__


.. py:class:: CodeNodeDAO

   Bases: :py:obj:`LanguageNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.CodeNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CodeNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ParallelNodeDAO

   Bases: :py:obj:`LanguageNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.ParallelNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ParallelNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: Point3MappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.Point3Mapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'Point3MappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: PoseMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.PoseMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PoseMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: position_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: rotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: position
      :type:  sqlalchemy.orm.Mapped[Point3MappingDAO]


   .. py:attribute:: rotation
      :type:  sqlalchemy.orm.Mapped[QuaternionMappingDAO]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: PoseStampedDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.PoseStamped`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PoseStampedDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: pose_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: header_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: pose
      :type:  sqlalchemy.orm.Mapped[PyCramPoseDAO]


   .. py:attribute:: header
      :type:  sqlalchemy.orm.Mapped[HeaderDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: GraspPoseDAO

   Bases: :py:obj:`PoseStampedDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.GraspPose`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'GraspPoseDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PositionVariableDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.degree_of_freedom.PositionVariable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PositionVariableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof
      :type:  sqlalchemy.orm.Mapped[DegreeOfFreedomMappingDAO]


.. py:class:: PouringActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.tool_based.PouringAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PouringActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: technique
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: angle
      :type:  sqlalchemy.orm.Mapped[Optional[float]]


   .. py:attribute:: object__id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tool_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: tool
      :type:  sqlalchemy.orm.Mapped[SemanticAnnotationDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PreferredGraspAlignmentDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.grasp.PreferredGraspAlignment`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PreferredGraspAlignmentDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: with_vertical_alignment
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: with_rotated_gripper
      :type:  sqlalchemy.orm.Mapped[bool]


.. py:class:: PrefixedNameDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.datastructures.prefixed_name.PrefixedName`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PrefixedNameDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: prefix
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


.. py:class:: PyCramPoseDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.PyCramPose`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PyCramPoseDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: position_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: orientation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: position
      :type:  sqlalchemy.orm.Mapped[PyCramVector3DAO]


   .. py:attribute:: orientation
      :type:  sqlalchemy.orm.Mapped[PyCRAMQuaternionMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PyCRAMQuaternionMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.PyCRAMQuaternionMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PyCRAMQuaternionMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: w
      :type:  sqlalchemy.orm.Mapped[float]


.. py:class:: PyCramVector3DAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.PyCramVector3`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PyCramVector3DAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: __mapper_args__


.. py:class:: QuaternionMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.QuaternionMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'QuaternionMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: w
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: ReachActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.pick_up.ReachAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ReachActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: target_pose_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_pose
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ReachMotionDAO

   Bases: :py:obj:`BaseMotionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.motions.gripper.ReachMotion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ReachMotionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: arm
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: movement_type
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.MovementType]


   .. py:attribute:: reverse_pose_sequence
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: grasp_description_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: grasp_description
      :type:  sqlalchemy.orm.Mapped[GraspDescriptionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RepeatPlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.RepeatPlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RepeatPlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ResolvedActionNodeMappingDAO

   Bases: :py:obj:`DesignatorNodeMappingDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.orm.model.ResolvedActionNodeMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ResolvedActionNodeMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: execution_data_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: execution_data
      :type:  sqlalchemy.orm.Mapped[ExecutionDataDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RotationMatrixMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.RotationMatrixMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RotationMatrixMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: rotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: rotation
      :type:  sqlalchemy.orm.Mapped[QuaternionMappingDAO]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: ScaleDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Scale`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ScaleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


.. py:class:: SearchActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.searching.SearchAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SearchActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_sem_annotation
      :type:  sqlalchemy.orm.Mapped[krrood.ormatic.custom_types.TypeType]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: SequentialNodeDAO

   Bases: :py:obj:`LanguageNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.SequentialNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SequentialNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MonitorNodeDAO

   Bases: :py:obj:`SequentialNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.MonitorNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MonitorNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: RepeatNodeDAO

   Bases: :py:obj:`SequentialNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.RepeatNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RepeatNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: repeat
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SequentialPlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.SequentialPlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SequentialPlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SetGripperActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.core.robot_body.SetGripperAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SetGripperActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: gripper
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.Arms]


   .. py:attribute:: motion
      :type:  sqlalchemy.orm.Mapped[pycram.datastructures.enums.GripperState]


   .. py:attribute:: __mapper_args__


.. py:class:: ShapeDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Shape`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ShapeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: origin_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: color_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: origin
      :type:  sqlalchemy.orm.Mapped[HomogeneousTransformationMatrixMappingDAO]


   .. py:attribute:: color
      :type:  sqlalchemy.orm.Mapped[ColorDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BoxDAO

   Bases: :py:obj:`ShapeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Box`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BoxDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: scale_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: scale
      :type:  sqlalchemy.orm.Mapped[ScaleDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: CylinderDAO

   Bases: :py:obj:`ShapeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Cylinder`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CylinderDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: width
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: height
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: __mapper_args__


.. py:class:: MeshDAO

   Bases: :py:obj:`ShapeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Mesh`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MeshDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: scale_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: scale
      :type:  sqlalchemy.orm.Mapped[ScaleDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: FileMeshDAO

   Bases: :py:obj:`MeshDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.FileMesh`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FileMeshDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: filename
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: __mapper_args__


.. py:class:: ShapeCollectionDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.shape_collection.ShapeCollection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ShapeCollectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: shapes
      :type:  sqlalchemy.orm.Mapped[List[ShapeDAO]]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BoundingBoxCollectionDAO

   Bases: :py:obj:`ShapeCollectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.shape_collection.BoundingBoxCollection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BoundingBoxCollectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SpatialRelationDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.SpatialRelation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SpatialRelationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: body_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: other_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: other
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: InsideOfDAO

   Bases: :py:obj:`SpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.InsideOf`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'InsideOfDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: containment_ratio
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: __mapper_args__


.. py:class:: SphereDAO

   Bases: :py:obj:`ShapeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.Sphere`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SphereDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: radius
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: __mapper_args__


.. py:class:: StateChangeCallbackDAO

   Bases: :py:obj:`CallbackDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.callbacks.callback.StateChangeCallback`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'StateChangeCallbackDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: previous_world_state_data
      :type:  sqlalchemy.orm.Mapped[pycram.orm.model.NumpyType]


   .. py:attribute:: __mapper_args__


.. py:class:: TransformDAO

   Bases: :py:obj:`PyCramPoseDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.Transform`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TransformDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TransformStampedDAO

   Bases: :py:obj:`PoseStampedDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.TransformStamped`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TransformStampedDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: child_frame_id_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: child_frame_id
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: TransportActionDAO

   Bases: :py:obj:`ActionDescriptionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.robot_plans.actions.composite.transporting.TransportAction`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TransportActionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: place_rotation_agnostic
      :type:  sqlalchemy.orm.Mapped[Optional[bool]]


   .. py:attribute:: object_designator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: target_location_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: object_designator
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: target_location
      :type:  sqlalchemy.orm.Mapped[PoseStampedDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: TriangleMeshDAO

   Bases: :py:obj:`MeshDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.geometry.TriangleMesh`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TriangleMeshDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: mesh
      :type:  sqlalchemy.orm.Mapped[Optional[semantic_digital_twin.orm.model.TrimeshType]]


   .. py:attribute:: __mapper_args__


.. py:class:: TryAllNodeDAO

   Bases: :py:obj:`ParallelNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.TryAllNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TryAllNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TryAllPLanDAO

   Bases: :py:obj:`ParallelPlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.TryAllPLan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TryAllPLanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TryInOrderNodeDAO

   Bases: :py:obj:`SequentialNodeDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.TryInOrderNode`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TryInOrderNodeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TryInOrderPlanDAO

   Bases: :py:obj:`LanguagePlanDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.language.TryInOrderPlan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TryInOrderPlanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: Vector3MappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.Vector3Mapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'Vector3MappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: y
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: z
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: reference_frame_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: reference_frame
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


.. py:class:: Vector3StampedDAO

   Bases: :py:obj:`PyCramVector3DAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`pycram.datastructures.pose.Vector3Stamped`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'Vector3StampedDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: header_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: header
      :type:  sqlalchemy.orm.Mapped[HeaderDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: VelocityVariableDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.degree_of_freedom.VelocityVariable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'VelocityVariableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof
      :type:  sqlalchemy.orm.Mapped[DegreeOfFreedomMappingDAO]


.. py:class:: ViewDependentSpatialRelationDAO

   Bases: :py:obj:`SpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.ViewDependentSpatialRelation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ViewDependentSpatialRelationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: eps
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: spatial_relation_result
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: point_of_semantic_annotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: point_of_semantic_annotation
      :type:  sqlalchemy.orm.Mapped[HomogeneousTransformationMatrixMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AboveDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.Above`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AboveDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BehindDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.Behind`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BehindDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BelowDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.Below`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BelowDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: InFrontOfDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.InFrontOf`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'InFrontOfDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: LeftOfDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.LeftOf`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LeftOfDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: RightOfDAO

   Bases: :py:obj:`ViewDependentSpatialRelationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.reasoning.predicates.RightOf`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RightOfDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: WorldMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.WorldMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: state_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: kinematic_structure_entities
      :type:  sqlalchemy.orm.Mapped[List[KinematicStructureEntityDAO]]


   .. py:attribute:: connections
      :type:  sqlalchemy.orm.Mapped[List[ConnectionDAO]]


   .. py:attribute:: semantic_annotations
      :type:  sqlalchemy.orm.Mapped[List[SemanticAnnotationDAO]]


   .. py:attribute:: degrees_of_freedom
      :type:  sqlalchemy.orm.Mapped[List[DegreeOfFreedomMappingDAO]]


   .. py:attribute:: state
      :type:  sqlalchemy.orm.Mapped[WorldStateMappingDAO]


.. py:class:: WorldEntityDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.WorldEntity`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldEntityDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: name_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: name
      :type:  sqlalchemy.orm.Mapped[PrefixedNameDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ConnectionDAO

   Bases: :py:obj:`WorldEntityDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Connection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ConnectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: child_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent_T_connection_expression_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: connection_T_child_expression_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: child
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: parent_T_connection_expression
      :type:  sqlalchemy.orm.Mapped[HomogeneousTransformationMatrixMappingDAO]


   .. py:attribute:: connection_T_child_expression
      :type:  sqlalchemy.orm.Mapped[HomogeneousTransformationMatrixMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ActiveConnectionDAO

   Bases: :py:obj:`ConnectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.ActiveConnection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ActiveConnectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: frozen_for_collision_avoidance
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: __mapper_args__


.. py:class:: ActiveConnection1DOFDAO

   Bases: :py:obj:`ActiveConnectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.ActiveConnection1DOF`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ActiveConnection1DOFDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: multiplier
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: offset
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: axis_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: axis
      :type:  sqlalchemy.orm.Mapped[Vector3MappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: PrismaticConnectionDAO

   Bases: :py:obj:`ActiveConnection1DOFDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.PrismaticConnection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PrismaticConnectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: RevoluteConnectionDAO

   Bases: :py:obj:`ActiveConnection1DOFDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.RevoluteConnection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RevoluteConnectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: OmniDriveDAO

   Bases: :py:obj:`ActiveConnectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.OmniDrive`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'OmniDriveDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: y_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: roll_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: pitch_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: yaw_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: x_velocity_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: y_velocity_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: Connection6DoFDAO

   Bases: :py:obj:`ConnectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.Connection6DoF`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'Connection6DoFDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: x_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: y_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: z_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: qx_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: qy_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: qz_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: qw_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: FixedConnectionDAO

   Bases: :py:obj:`ConnectionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.connections.FixedConnection`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FixedConnectionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SemanticAnnotationDAO

   Bases: :py:obj:`WorldEntityDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.SemanticAnnotation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SemanticAnnotationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DoubleDoorDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.DoubleDoor`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DoubleDoorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: left_door_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: right_door_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: left_door
      :type:  sqlalchemy.orm.Mapped[DoorDAO]


   .. py:attribute:: right_door
      :type:  sqlalchemy.orm.Mapped[DoorDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: DrawerDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Drawer`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DrawerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: handle_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: handle
      :type:  sqlalchemy.orm.Mapped[HandleDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: FridgeDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Fridge`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FridgeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: door_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: door
      :type:  sqlalchemy.orm.Mapped[DoorDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: FurnitureDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.Furniture`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FurnitureDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: HasBodyDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.HasBody`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HasBodyDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BaseballDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Baseball`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BaseballDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BedDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Bed`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BedDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BookDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Book`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BookDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: book_front_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: book_front
      :type:  sqlalchemy.orm.Mapped[BookFrontDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BookFrontDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.BookFront`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BookFrontDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ChairDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Chair`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ChairDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ArmchairDAO

   Bases: :py:obj:`ChairDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Armchair`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ArmchairDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: OfficeChairDAO

   Bases: :py:obj:`ChairDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.OfficeChair`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'OfficeChairDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ClothDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cloth`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ClothDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ContainerDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Container`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ContainerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BottleDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Bottle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BottleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MustardBottleDAO

   Bases: :py:obj:`BottleDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.MustardBottle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MustardBottleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SoapBottleDAO

   Bases: :py:obj:`BottleDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.SoapBottle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SoapBottleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: WineBottleDAO

   Bases: :py:obj:`BottleDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.WineBottle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WineBottleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: GarbageBinDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.GarbageBin`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'GarbageBinDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ProcthorBoxDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.ProcthorBox`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ProcthorBoxDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SaltContainerDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.SaltContainer`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SaltContainerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: CookingContainerDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.CookingContainer`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CookingContainerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: KettleDAO

   Bases: :py:obj:`CookingContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Kettle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'KettleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PanDAO

   Bases: :py:obj:`CookingContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Pan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PotDAO

   Bases: :py:obj:`CookingContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Pot`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PotDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CuttleryDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cuttlery`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CuttleryDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ForkDAO

   Bases: :py:obj:`CuttleryDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Fork`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ForkDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: KnifeDAO

   Bases: :py:obj:`CuttleryDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Knife`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'KnifeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SpoonDAO

   Bases: :py:obj:`CuttleryDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Spoon`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SpoonDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: DecorDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Decor`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DecorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: WallDecorDAO

   Bases: :py:obj:`DecorDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.WallDecor`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WallDecorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PosterDAO

   Bases: :py:obj:`WallDecorDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Poster`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PosterDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DoorDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Door`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DoorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: handle_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: handle
      :type:  sqlalchemy.orm.Mapped[HandleDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: DrinkingContainerDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.DrinkingContainer`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DrinkingContainerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CupDAO

   Bases: :py:obj:`DrinkingContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cup`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CupDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: MugDAO

   Bases: :py:obj:`DrinkingContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Mug`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MugDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DroneDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Drone`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DroneDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: FoodDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Food`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FoodDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BreadDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Bread`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BreadDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CandyDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Candy`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CandyDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: CerealDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cereal`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CerealDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: CheezeItDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.CheezeIt`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CheezeItDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: GelatinBoxDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.GelatinBox`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'GelatinBoxDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: MilkDAO

   Bases: :py:obj:`ContainerDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Milk`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'MilkDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: NoodlesDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Noodles`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'NoodlesDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: __mapper_args__


.. py:class:: PringlesDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Pringles`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PringlesDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ProduceDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Produce`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ProduceDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: AppleDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Apple`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AppleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: BananaDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Banana`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BananaDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: LettuceDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Lettuce`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LettuceDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: OrangeDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Orange`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'OrangeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PotatoDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Potato`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PotatoDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TomatoDAO

   Bases: :py:obj:`ProduceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Tomato`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TomatoDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TomatoSoupDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.TomatoSoup`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TomatoSoupDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TunaCanDAO

   Bases: :py:obj:`FoodDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.TunaCan`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TunaCanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: HandleDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Handle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HandleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: HouseplantDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Houseplant`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HouseplantDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: LidDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Lid`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LidDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PanLidDAO

   Bases: :py:obj:`LidDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.PanLid`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PanLidDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PotLidDAO

   Bases: :py:obj:`LidDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.PotLid`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PotLidDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: LiquidCapDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.LiquidCap`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'LiquidCapDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PenDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Pen`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PenDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PencilDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Pencil`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PencilDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SaltPepperShakerDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.SaltPepperShaker`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SaltPepperShakerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ShelvingUnitDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.ShelvingUnit`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ShelvingUnitDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SinkDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Sink`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SinkDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SofaDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Sofa`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SofaDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SprayBottleDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.SprayBottle`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SprayBottleDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: StatueDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Statue`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'StatueDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: TableDAO

   Bases: :py:obj:`FurnitureDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Table`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: CoffeeTableDAO

   Bases: :py:obj:`TableDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.CoffeeTable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CoffeeTableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DeskDAO

   Bases: :py:obj:`TableDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Desk`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DeskDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DiningTableDAO

   Bases: :py:obj:`TableDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.DiningTable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DiningTableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SideTableDAO

   Bases: :py:obj:`TableDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.SideTable`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SideTableDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: VaseDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Vase`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'VaseDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: WallPanelDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.WallPanel`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WallPanelDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: HasDoorsDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.HasDoors`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HasDoorsDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: doors
      :type:  sqlalchemy.orm.Mapped[List[DoorDAO]]


   .. py:attribute:: __mapper_args__


.. py:class:: CupboardDAO

   Bases: :py:obj:`FurnitureDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cupboard`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CupboardDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: doors
      :type:  sqlalchemy.orm.Mapped[List[DoorDAO]]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: HasDrawersDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.HasDrawers`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HasDrawersDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: drawers
      :type:  sqlalchemy.orm.Mapped[List[DrawerDAO]]


   .. py:attribute:: __mapper_args__


.. py:class:: CabinetDAO

   Bases: :py:obj:`FurnitureDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Cabinet`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CabinetDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: doors
      :type:  sqlalchemy.orm.Mapped[List[DoorDAO]]


   .. py:attribute:: drawers
      :type:  sqlalchemy.orm.Mapped[List[DrawerDAO]]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: DresserDAO

   Bases: :py:obj:`FurnitureDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Dresser`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DresserDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: doors
      :type:  sqlalchemy.orm.Mapped[List[DoorDAO]]


   .. py:attribute:: drawers
      :type:  sqlalchemy.orm.Mapped[List[DrawerDAO]]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: WardrobeDAO

   Bases: :py:obj:`FurnitureDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Wardrobe`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WardrobeDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: container_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: doors
      :type:  sqlalchemy.orm.Mapped[List[DoorDAO]]


   .. py:attribute:: drawers
      :type:  sqlalchemy.orm.Mapped[List[DrawerDAO]]


   .. py:attribute:: container
      :type:  sqlalchemy.orm.Mapped[ContainerDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: HasRegionDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.HasRegion`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HasRegionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: region_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: region
      :type:  sqlalchemy.orm.Mapped[RegionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ApertureDAO

   Bases: :py:obj:`HasRegionDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Aperture`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ApertureDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: HasSupportingSurfaceDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.mixins.HasSupportingSurface`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HasSupportingSurfaceDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: supporting_surface_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: supporting_surface
      :type:  sqlalchemy.orm.Mapped[RegionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: BowlDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Bowl`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BowlDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: class_label
      :type:  sqlalchemy.orm.Mapped[Optional[str]]


   .. py:attribute:: supporting_surface_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: supporting_surface
      :type:  sqlalchemy.orm.Mapped[RegionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: FloorDAO

   Bases: :py:obj:`HasSupportingSurfaceDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Floor`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FloorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: PlateDAO

   Bases: :py:obj:`HasBodyDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Plate`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'PlateDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: supporting_surface_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: supporting_surface
      :type:  sqlalchemy.orm.Mapped[RegionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RoomDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Room`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RoomDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: floor_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: floor
      :type:  sqlalchemy.orm.Mapped[FloorDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RootedSemanticAnnotationDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.RootedSemanticAnnotation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RootedSemanticAnnotationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: root_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: root
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AgentDAO

   Bases: :py:obj:`RootedSemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Agent`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AgentDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: AbstractRobotDAO

   Bases: :py:obj:`AgentDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.AbstractRobot`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AbstractRobotDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: torso_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: default_collision_config_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: torso
      :type:  sqlalchemy.orm.Mapped[TorsoDAO]


   .. py:attribute:: manipulators
      :type:  sqlalchemy.orm.Mapped[List[ManipulatorDAO]]


   .. py:attribute:: sensors
      :type:  sqlalchemy.orm.Mapped[List[SensorDAO]]


   .. py:attribute:: manipulator_chains
      :type:  sqlalchemy.orm.Mapped[List[KinematicChainDAO]]


   .. py:attribute:: sensor_chains
      :type:  sqlalchemy.orm.Mapped[List[KinematicChainDAO]]


   .. py:attribute:: default_collision_config
      :type:  sqlalchemy.orm.Mapped[CollisionCheckingConfigDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: HumanDAO

   Bases: :py:obj:`AgentDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Human`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'HumanDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SemanticEnvironmentAnnotationDAO

   Bases: :py:obj:`RootedSemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.SemanticEnvironmentAnnotation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SemanticEnvironmentAnnotationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: SemanticRobotAnnotationDAO

   Bases: :py:obj:`RootedSemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.SemanticRobotAnnotation`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SemanticRobotAnnotationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: KinematicChainDAO

   Bases: :py:obj:`SemanticRobotAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.KinematicChain`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'KinematicChainDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tip_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: manipulator_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: tip
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: manipulator
      :type:  sqlalchemy.orm.Mapped[ManipulatorDAO]


   .. py:attribute:: sensors
      :type:  sqlalchemy.orm.Mapped[List[SensorDAO]]


   .. py:attribute:: __mapper_args__


.. py:class:: ArmDAO

   Bases: :py:obj:`KinematicChainDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Arm`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ArmDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: FingerDAO

   Bases: :py:obj:`KinematicChainDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Finger`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'FingerDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: NeckDAO

   Bases: :py:obj:`KinematicChainDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Neck`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'NeckDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: pitch_body_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: yaw_body_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: pitch_body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: yaw_body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: TorsoDAO

   Bases: :py:obj:`KinematicChainDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Torso`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'TorsoDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: ManipulatorDAO

   Bases: :py:obj:`SemanticRobotAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Manipulator`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ManipulatorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tool_frame_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: front_facing_orientation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: front_facing_axis_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: tool_frame
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: front_facing_orientation
      :type:  sqlalchemy.orm.Mapped[QuaternionMappingDAO]


   .. py:attribute:: front_facing_axis
      :type:  sqlalchemy.orm.Mapped[Vector3MappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: ParallelGripperDAO

   Bases: :py:obj:`ManipulatorDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.ParallelGripper`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ParallelGripperDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: finger_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: thumb_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: finger
      :type:  sqlalchemy.orm.Mapped[FingerDAO]


   .. py:attribute:: thumb
      :type:  sqlalchemy.orm.Mapped[FingerDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: SensorDAO

   Bases: :py:obj:`SemanticRobotAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Sensor`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SensorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: CameraDAO

   Bases: :py:obj:`SensorDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.robots.abstract_robot.Camera`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'CameraDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: minimal_height
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: maximal_height
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: forward_facing_axis_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: field_of_view_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: forward_facing_axis
      :type:  sqlalchemy.orm.Mapped[Vector3MappingDAO]


   .. py:attribute:: field_of_view
      :type:  sqlalchemy.orm.Mapped[FieldOfViewDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: WallDAO

   Bases: :py:obj:`SemanticAnnotationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.semantic_annotations.semantic_annotations.Wall`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WallDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body
      :type:  sqlalchemy.orm.Mapped[BodyDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: WorldEntityWithIDDAO

   Bases: :py:obj:`WorldEntityDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.WorldEntityWithID`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldEntityWithIDDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: ActuatorDAO

   Bases: :py:obj:`WorldEntityWithIDDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Actuator`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ActuatorDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: __mapper_args__


.. py:class:: DegreeOfFreedomMappingDAO

   Bases: :py:obj:`WorldEntityWithIDDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.DegreeOfFreedomMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'DegreeOfFreedomMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: lower_limits
      :type:  sqlalchemy.orm.Mapped[List[float]]


   .. py:attribute:: upper_limits
      :type:  sqlalchemy.orm.Mapped[List[float]]


   .. py:attribute:: __mapper_args__


.. py:class:: KinematicStructureEntityDAO

   Bases: :py:obj:`WorldEntityWithIDDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.KinematicStructureEntity`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'KinematicStructureEntityDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: index
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: __mapper_args__


.. py:class:: BodyDAO

   Bases: :py:obj:`KinematicStructureEntityDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Body`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'BodyDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: visual_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: collision_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: collision_config_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: temp_collision_config_id
      :type:  sqlalchemy.orm.Mapped[Optional[int]]


   .. py:attribute:: visual
      :type:  sqlalchemy.orm.Mapped[ShapeCollectionDAO]


   .. py:attribute:: collision
      :type:  sqlalchemy.orm.Mapped[ShapeCollectionDAO]


   .. py:attribute:: collision_config
      :type:  sqlalchemy.orm.Mapped[CollisionCheckingConfigDAO]


   .. py:attribute:: temp_collision_config
      :type:  sqlalchemy.orm.Mapped[CollisionCheckingConfigDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RegionDAO

   Bases: :py:obj:`KinematicStructureEntityDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_entity.Region`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RegionDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: area_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: area
      :type:  sqlalchemy.orm.Mapped[ShapeCollectionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: WorldModelModificationDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.WorldModelModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldModelModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: polymorphic_type
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: __mapper_args__


.. py:class:: AddActuatorModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.AddActuatorModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AddActuatorModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: actuator_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: actuator
      :type:  sqlalchemy.orm.Mapped[ActuatorDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AddConnectionModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.AddConnectionModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AddConnectionModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: connection_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: connection
      :type:  sqlalchemy.orm.Mapped[ConnectionDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AddDegreeOfFreedomModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.AddDegreeOfFreedomModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AddDegreeOfFreedomModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof
      :type:  sqlalchemy.orm.Mapped[DegreeOfFreedomMappingDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AddKinematicStructureEntityModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.AddKinematicStructureEntityModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AddKinematicStructureEntityModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: kinematic_structure_entity_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: kinematic_structure_entity
      :type:  sqlalchemy.orm.Mapped[KinematicStructureEntityDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: AddSemanticAnnotationModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.AddSemanticAnnotationModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'AddSemanticAnnotationModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: semantic_annotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: semantic_annotation
      :type:  sqlalchemy.orm.Mapped[SemanticAnnotationDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: RemoveActuatorModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.RemoveActuatorModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RemoveActuatorModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: actuator_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: RemoveBodyModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.RemoveBodyModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RemoveBodyModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: body_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: RemoveConnectionModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.RemoveConnectionModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RemoveConnectionModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: parent_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: child_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: RemoveDegreeOfFreedomModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.RemoveDegreeOfFreedomModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RemoveDegreeOfFreedomModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: dof_id
      :type:  sqlalchemy.orm.Mapped[sqlalchemy.sql.sqltypes.UUID]


   .. py:attribute:: __mapper_args__


.. py:class:: RemoveSemanticAnnotationModificationDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.RemoveSemanticAnnotationModification`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'RemoveSemanticAnnotationModificationDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: semantic_annotation_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: semantic_annotation
      :type:  sqlalchemy.orm.Mapped[SemanticAnnotationDAO]


   .. py:attribute:: __mapper_args__


.. py:class:: SetDofHasHardwareInterfaceDAO

   Bases: :py:obj:`WorldModelModificationDAO`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.SetDofHasHardwareInterface`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'SetDofHasHardwareInterfaceDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: value
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: degree_of_freedom_ids
      :type:  sqlalchemy.orm.Mapped[List[uuid.UUID]]


   .. py:attribute:: __mapper_args__


.. py:class:: WorldModelModificationBlockDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.world_description.world_modification.WorldModelModificationBlock`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldModelModificationBlockDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: modifications
      :type:  sqlalchemy.orm.Mapped[List[WorldModelModificationDAO]]


.. py:class:: WorldStateMappingDAO

   Bases: :py:obj:`Base`, :py:obj:`krrood.ormatic.dao.DataAccessObject`\ [\ :py:obj:`semantic_digital_twin.orm.model.WorldStateMapping`\ ]


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase


       class Base(DeclarativeBase):
           pass

   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()


       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger(),
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'WorldStateMappingDAO'



   .. py:attribute:: database_id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: data
      :type:  sqlalchemy.orm.Mapped[List[float]]


   .. py:attribute:: ids
      :type:  sqlalchemy.orm.Mapped[List[uuid.UUID]]


